<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gesture Drawing with Brushes</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}
    video{z-index:0;transform:scaleX(-1)}
    canvas{z-index:1}
    #hud{
      position:fixed;top:10px;left:10px;
      background:rgba(0,0,0,0.6);color:#fff;
      padding:10px 14px;border-radius:12px;
      font-family:sans-serif;font-size:14px;
      z-index:10;line-height:1.4em;min-width:200px;
    }
    #colorBox{
      display:inline-block;width:16px;height:16px;
      vertical-align:middle;margin-left:6px;
      border:1px solid #fff;border-radius:4px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>
  <video id="camera" autoplay playsinline></video>
  <canvas id="paint"></canvas>
  <div id="hud">
    ‚úã Controls:<br>
    ‚òù 1 finger ‚Üí Draw<br>
    ‚úå 2 fingers (up/down) ‚Üí Color<br>
    ü§ô Pinky ‚Üí Brush size<br>
    üëç Thumb ‚Üí Brush type<br>
    üñê Palm ‚Üí Clear<br><br>
    <b>Current:</b><br>
    Brush: <span id="brushName"></span><br>
    Size: <span id="sizeText"></span>px<br>
    Color: <span id="colorBox"></span>
  </div>

  <script>
    const video=document.getElementById('camera');
    const canvas=document.getElementById('paint');
    const ctx=canvas.getContext('2d');
    const brushName=document.getElementById('brushName');
    const sizeText=document.getElementById('sizeText');
    const colorBox=document.getElementById('colorBox');

    function fit(){canvas.width=innerWidth;canvas.height=innerHeight;}
    addEventListener('resize',fit);fit();

    const colors=['#fff','#ff3b30','#34c759','#0a84ff','#ffcc00','#ff00ff'];
    let colorIndex=0;
    let brushColor=colors[colorIndex];

    const brushSizes=[5,15,30,50];
    let brushSizeIndex=1;

    const brushTypes=['Pen','Soft Brush','Bristle','Paddle'];
    let brushTypeIndex=0;

    function updateHUD(){
      brushName.textContent=brushTypes[brushTypeIndex];
      sizeText.textContent=brushSizes[brushSizeIndex];
      colorBox.style.background=brushColor;
    }
    updateHUD();

    // Drawing functions
    function drawStroke(from,to){
      const size=brushSizes[brushSizeIndex];
      const type=brushTypes[brushTypeIndex];

      if(type==='Pen'){
        ctx.strokeStyle=brushColor;
        ctx.lineWidth=size/2;
        ctx.lineCap="round";
        ctx.beginPath();
        ctx.moveTo(from.x,from.y);
        ctx.lineTo(to.x,to.y);
        ctx.stroke();
      }
      else if(type==='Soft Brush'){
        const grad=ctx.createRadialGradient(to.x,to.y,1,to.x,to.y,size/2);
        grad.addColorStop(0,brushColor);
        grad.addColorStop(1,brushColor+"00");
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.arc(to.x,to.y,size/2,0,Math.PI*2);
        ctx.fill();
      }
      else if(type==='Bristle'){
        const steps=6;
        for(let i=0;i<steps;i++){
          const angle=Math.random()*Math.PI*2;
          const r=(Math.random()*size*0.6)-(size*0.3);
          const px=to.x+Math.cos(angle)*r;
          const py=to.y+Math.sin(angle)*r;
          ctx.beginPath();
          ctx.arc(px,py,Math.random()*2+0.5,0,Math.PI*2);
          ctx.fillStyle=brushColor+Math.floor(Math.random()*90+40).toString(16);
          ctx.fill();
        }
      }
      else if(type==='Paddle'){
        ctx.save();
        ctx.translate(to.x,to.y);
        const angle=Math.atan2(to.y-from.y,to.x-from.x);
        ctx.rotate(angle);
        ctx.fillStyle=brushColor;
        ctx.fillRect(-size/2,-size/8,size,size/4);
        ctx.restore();
      }
    }

    function toCanvasX(x){return (1-x)*canvas.width;}
    function toCanvasY(y){return y*canvas.height;}

    function countFingers(lm,isRight){
      let c=0;
      const thumb=isRight?(lm[4].x<lm[3].x):(lm[4].x>lm[3].x);
      if(thumb)c++;
      const tips=[8,12,16,20],pips=[6,10,14,18];
      for(let i=0;i<4;i++) if(lm[tips[i]].y<lm[pips[i]].y)c++;
      return c;
    }

    function whichFingersUp(lm,isRight){
      const up=[];
      const thumb=isRight?(lm[4].x<lm[3].x):(lm[4].x>lm[3].x);
      if(thumb) up.push('thumb');
      if(lm[8].y<lm[6].y) up.push('index');
      if(lm[12].y<lm[10].y) up.push('middle');
      if(lm[16].y<lm[14].y) up.push('ring');
      if(lm[20].y<lm[18].y) up.push('pinky');
      return up;
    }

    let lastPt=null;
    let lastGestureAt=0;
    const GESTURE_COOLDOWN=400;
    let lastTwoY=null;

    function handleGestures(fingers,lm,pt,isRight){
      const now=performance.now();

      // Draw with index
      if(fingers===1){
        if(lastPt) drawStroke(lastPt,pt);
        lastPt=pt;
      } else lastPt=null;

      const up=whichFingersUp(lm,isRight);

      // Pinky only ‚Üí Brush size
      if(up.length===1 && up[0]==='pinky' && now-lastGestureAt>GESTURE_COOLDOWN){
        brushSizeIndex=(brushSizeIndex+1)%brushSizes.length;
        updateHUD();
        lastGestureAt=now;
      }

      // Thumb only ‚Üí Brush type
      if(up.length===1 && up[0]==='thumb' && now-lastGestureAt>GESTURE_COOLDOWN){
        brushTypeIndex=(brushTypeIndex+1)%brushTypes.length;
        updateHUD();
        lastGestureAt=now;
      }

      // Open palm ‚Üí clear
      if(fingers===5 && now-lastGestureAt>GESTURE_COOLDOWN){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        lastGestureAt=now;
      }

      // Two fingers ‚Üí color change
      if(fingers===2){
        const yAvg=(lm[8].y+lm[12].y)/2;
        if(lastTwoY!==null){
          const dy=yAvg-lastTwoY;
          if(Math.abs(dy)>0.05){
            if(dy<0) colorIndex=(colorIndex+1)%colors.length;
            else colorIndex=(colorIndex-1+colors.length)%colors.length;
            brushColor=colors[colorIndex];
            updateHUD();
            lastGestureAt=now;
          }
        }
        lastTwoY=yAvg;
      } else lastTwoY=null;
    }

    const hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({maxNumHands:1,modelComplexity:0,minDetectionConfidence:0.6,minTrackingConfidence:0.6});
    hands.onResults(results=>{
      if(!results.multiHandLandmarks||results.multiHandLandmarks.length===0){lastPt=null;return;}
      const lm=results.multiHandLandmarks[0];
      const info=results.multiHandedness?results.multiHandedness[0]:null;
      const isRight=info?info.label==='Right':true;
      const idx=lm[8];
      const pt={x:toCanvasX(idx.x),y:toCanvasY(idx.y)};
      const fingers=countFingers(lm,isRight);
      handleGestures(fingers,lm,pt,isRight);
    });

    const cam=new Camera(video,{onFrame:async()=>{await hands.send({image:video});},width:640,height:480});
    cam.start();

    
  </script>
</body>
</html>
